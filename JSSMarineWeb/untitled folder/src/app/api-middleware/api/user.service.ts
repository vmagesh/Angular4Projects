/**
 * Catchup APIs
 * The Catchup API document is intended strictly for internal use only.
 *
 * OpenAPI spec version: 1.0.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional } from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams, HttpResponse, HttpEvent } from '@angular/common/http';
import { CustomHttpUrlEncodingCodec } from '../encoder';

import { Observable } from 'rxjs/Observable';

import { BlockUser } from '../model/blockUser';
import { CreateRegistration } from '../model/createRegistration';
import { DeviceId } from '../model/deviceId';
import { DeviceSettings } from '../model/deviceSettings';
import { GetContactInfo } from '../model/getContactInfo';
import { InlineResponse2001 } from '../model/inlineResponse2001';
import { InlineResponse2002 } from '../model/inlineResponse2002';
import { InlineResponse2003 } from '../model/inlineResponse2003';
import { InlineResponse2004 } from '../model/inlineResponse2004';
import { InlineResponse2005 } from '../model/inlineResponse2005';
import { InlineResponse2006 } from '../model/inlineResponse2006';
import { InlineResponse2007 } from '../model/inlineResponse2007';
import { InlineResponse2008 } from '../model/inlineResponse2008';
import { InlineResponse2009 } from '../model/inlineResponse2009';
import { InlineResponse400 } from '../model/inlineResponse400';
import { Profile } from '../model/profile';
import { SetLogin } from '../model/setLogin';
import { UpdateLogin } from '../model/updateLogin';
import { UpdatePhoneNumber } from '../model/updatePhoneNumber';
import { UploadProfilePic } from '../model/uploadProfilePic';
import { VerifyLoginRegister } from '../model/verifyLoginRegister';
import { VerifyPin } from '../model/verifyPin';
import { VerifyPinRegister } from '../model/verifyPinRegister';

import { BASE_PATH, COLLECTION_FORMATS } from '../variables';
import { Configuration } from '../configuration';

@Injectable()
export class UserService {
  protected basePath = '';
  public defaultHeaders = new HttpHeaders();
  public configuration = new Configuration();

  constructor(
    protected httpClient: HttpClient,
    @Optional() @Inject(BASE_PATH) basePath: string,
    @Optional() configuration: Configuration
  ) {
    if (basePath) {
      this.basePath = basePath;
    }
    console.log(configuration);
    if (configuration) {
      this.configuration = configuration;
      this.configuration.apiKeys['Authorization'] = localStorage.getItem('jwt-token');
      this.basePath = basePath || configuration.basePath || this.basePath;
    }
  }

  /**
   * @param consumes string[] mime-types
   * @return true: consumes contains 'multipart/form-data', false: otherwise
   */
  private canConsumeForm(consumes: string[]): boolean {
    const form = 'multipart/form-data';
    for (const consume of consumes) {
      if (form === consume) {
        return true;
      }
    }
    return false;
  }

  /**
   * To get the blocked contacts
   * This API fetches all the contacts the user has blocked.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public userBlockGet(observe?: 'body', reportProgress?: boolean): Observable<InlineResponse2008>;
  public userBlockGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<InlineResponse2008>>;
  public userBlockGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<InlineResponse2008>>;
  public userBlockGet(observe: any = 'body', reportProgress: boolean = false): Observable<any> {
    let headers = this.defaultHeaders;

    // authentication (Bearer) required
    if (this.configuration.apiKeys['Authorization']) {
      headers = headers.set('Authorization', this.configuration.apiKeys['Authorization']);
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = [];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [];

    return this.httpClient.get<InlineResponse2008>(`${this.basePath}/user/block`, {
      withCredentials: this.configuration.withCredentials,
      headers: headers,
      observe: observe,
      reportProgress: reportProgress
    });
  }

  /**
   * To block/unblock a user
   * This API blocks r unblocks a contact number from users contacts
   * @param body contact information that has to be blocked
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public userBlockPost(body: BlockUser, observe?: 'body', reportProgress?: boolean): Observable<InlineResponse400>;
  public userBlockPost(
    body: BlockUser,
    observe?: 'response',
    reportProgress?: boolean
  ): Observable<HttpResponse<InlineResponse400>>;
  public userBlockPost(
    body: BlockUser,
    observe?: 'events',
    reportProgress?: boolean
  ): Observable<HttpEvent<InlineResponse400>>;
  public userBlockPost(body: BlockUser, observe: any = 'body', reportProgress: boolean = false): Observable<any> {
    if (body === null || body === undefined) {
      throw new Error('Required parameter body was null or undefined when calling userBlockPost.');
    }

    let headers = this.defaultHeaders;

    // authentication (Bearer) required
    if (this.configuration.apiKeys['Authorization']) {
      headers = headers.set('Authorization', this.configuration.apiKeys['Authorization']);
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = [];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected != undefined) {
      headers = headers.set('Content-Type', httpContentTypeSelected);
    }

    return this.httpClient.post<InlineResponse400>(`${this.basePath}/user/block`, body, {
      withCredentials: this.configuration.withCredentials,
      headers: headers,
      observe: observe,
      reportProgress: reportProgress
    });
  }

  /**
   * To get the contact details
   * This API fetches the contact details of the updated contact details.
   * @param body Contact list for which the information has to be fetched.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public userContactInfoPost(
    body: GetContactInfo,
    observe?: 'body',
    reportProgress?: boolean
  ): Observable<InlineResponse2007>;
  public userContactInfoPost(
    body: GetContactInfo,
    observe?: 'response',
    reportProgress?: boolean
  ): Observable<HttpResponse<InlineResponse2007>>;
  public userContactInfoPost(
    body: GetContactInfo,
    observe?: 'events',
    reportProgress?: boolean
  ): Observable<HttpEvent<InlineResponse2007>>;
  public userContactInfoPost(
    body: GetContactInfo,
    observe: any = 'body',
    reportProgress: boolean = false
  ): Observable<any> {
    if (body === null || body === undefined) {
      throw new Error('Required parameter body was null or undefined when calling userContactInfoPost.');
    }

    let headers = this.defaultHeaders;

    // authentication (Bearer) required
    if (this.configuration.apiKeys['Authorization']) {
      headers = headers.set('Authorization', this.configuration.apiKeys['Authorization']);
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = [];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected != undefined) {
      headers = headers.set('Content-Type', httpContentTypeSelected);
    }

    return this.httpClient.post<InlineResponse2007>(`${this.basePath}/user/contact-info`, body, {
      withCredentials: this.configuration.withCredentials,
      headers: headers,
      observe: observe,
      reportProgress: reportProgress
    });
  }

  /**
   * To create a registration
   * This API creates the registration.
   * @param body registration information that has to be initiated in the database
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public userCreateRegistrationPost(
    body: CreateRegistration,
    observe?: 'body',
    reportProgress?: boolean
  ): Observable<InlineResponse2001>;
  public userCreateRegistrationPost(
    body: CreateRegistration,
    observe?: 'response',
    reportProgress?: boolean
  ): Observable<HttpResponse<InlineResponse2001>>;
  public userCreateRegistrationPost(
    body: CreateRegistration,
    observe?: 'events',
    reportProgress?: boolean
  ): Observable<HttpEvent<InlineResponse2001>>;
  public userCreateRegistrationPost(
    body: CreateRegistration,
    observe: any = 'body',
    reportProgress: boolean = false
  ): Observable<any> {
    if (body === null || body === undefined) {
      throw new Error('Required parameter body was null or undefined when calling userCreateRegistrationPost.');
    }

    let headers = this.defaultHeaders;

    // authentication (basicAuth) required
    if (this.configuration.username || this.configuration.password) {
      headers = headers.set(
        'Authorization',
        'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password)
      );
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = [];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected != undefined) {
      headers = headers.set('Content-Type', httpContentTypeSelected);
    }

    return this.httpClient.post<InlineResponse2001>(`${this.basePath}/user/create-registration`, body, {
      withCredentials: this.configuration.withCredentials,
      headers: headers,
      observe: observe,
      reportProgress: reportProgress
    });
  }

  /**
   * Delete account from catchup
   * To delete the account permanently from catch up.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public userDeleteAccountDelete(observe?: 'body', reportProgress?: boolean): Observable<InlineResponse400>;
  public userDeleteAccountDelete(
    observe?: 'response',
    reportProgress?: boolean
  ): Observable<HttpResponse<InlineResponse400>>;
  public userDeleteAccountDelete(
    observe?: 'events',
    reportProgress?: boolean
  ): Observable<HttpEvent<InlineResponse400>>;
  public userDeleteAccountDelete(observe: any = 'body', reportProgress: boolean = false): Observable<any> {
    let headers = this.defaultHeaders;

    // authentication (Bearer) required
    if (this.configuration.apiKeys['Authorization']) {
      headers = headers.set('Authorization', this.configuration.apiKeys['Authorization']);
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = [];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [];
    console.log(`${this.basePath}/v1/user/delete-account`);
    return this.httpClient.delete<InlineResponse400>(`${this.basePath}/v1/user/delete-account`, {
      withCredentials: this.configuration.withCredentials,
      headers: headers,
      observe: observe,
      reportProgress: reportProgress
    });
  }

  /**
   * To update users device ID
   * This API updates the device ID of the user based on his user_id
   * @param body update device id based on user_id
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public userDeviceIdPost(body: DeviceId, observe?: 'body', reportProgress?: boolean): Observable<InlineResponse400>;
  public userDeviceIdPost(
    body: DeviceId,
    observe?: 'response',
    reportProgress?: boolean
  ): Observable<HttpResponse<InlineResponse400>>;
  public userDeviceIdPost(
    body: DeviceId,
    observe?: 'events',
    reportProgress?: boolean
  ): Observable<HttpEvent<InlineResponse400>>;
  public userDeviceIdPost(body: DeviceId, observe: any = 'body', reportProgress: boolean = false): Observable<any> {
    if (body === null || body === undefined) {
      throw new Error('Required parameter body was null or undefined when calling userDeviceIdPost.');
    }

    let headers = this.defaultHeaders;

    // authentication (Bearer) required
    if (this.configuration.apiKeys['Authorization']) {
      headers = headers.set('Authorization', this.configuration.apiKeys['Authorization']);
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = [];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected != undefined) {
      headers = headers.set('Content-Type', httpContentTypeSelected);
    }

    return this.httpClient.post<InlineResponse400>(`${this.basePath}/user/device/id`, body, {
      withCredentials: this.configuration.withCredentials,
      headers: headers,
      observe: observe,
      reportProgress: reportProgress
    });
  }

  /**
   * To update users device ID
   * This API updates the device ID of the user based on his user_id
   * @param body update device settings based on user_id
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public userDeviceSettingsPost(
    body: DeviceSettings,
    observe?: 'body',
    reportProgress?: boolean
  ): Observable<InlineResponse400>;
  public userDeviceSettingsPost(
    body: DeviceSettings,
    observe?: 'response',
    reportProgress?: boolean
  ): Observable<HttpResponse<InlineResponse400>>;
  public userDeviceSettingsPost(
    body: DeviceSettings,
    observe?: 'events',
    reportProgress?: boolean
  ): Observable<HttpEvent<InlineResponse400>>;
  public userDeviceSettingsPost(
    body: DeviceSettings,
    observe: any = 'body',
    reportProgress: boolean = false
  ): Observable<any> {
    if (body === null || body === undefined) {
      throw new Error('Required parameter body was null or undefined when calling userDeviceSettingsPost.');
    }

    let headers = this.defaultHeaders;

    // authentication (Bearer) required
    if (this.configuration.apiKeys['Authorization']) {
      headers = headers.set('Authorization', this.configuration.apiKeys['Authorization']);
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = [];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected != undefined) {
      headers = headers.set('Content-Type', httpContentTypeSelected);
    }

    return this.httpClient.post<InlineResponse400>(`${this.basePath}/user/device/settings`, body, {
      withCredentials: this.configuration.withCredentials,
      headers: headers,
      observe: observe,
      reportProgress: reportProgress
    });
  }

  /**
   * To get the launch information
   * This API fetches the launch information
   * @param device_os The device_os for which the launch information has to be shared.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public userLaunchInfoDeviceOsGet(
    device_os: number,
    observe?: 'body',
    reportProgress?: boolean
  ): Observable<InlineResponse2009>;
  public userLaunchInfoDeviceOsGet(
    device_os: number,
    observe?: 'response',
    reportProgress?: boolean
  ): Observable<HttpResponse<InlineResponse2009>>;
  public userLaunchInfoDeviceOsGet(
    device_os: number,
    observe?: 'events',
    reportProgress?: boolean
  ): Observable<HttpEvent<InlineResponse2009>>;
  public userLaunchInfoDeviceOsGet(
    device_os: number,
    observe: any = 'body',
    reportProgress: boolean = false
  ): Observable<any> {
    if (device_os === null || device_os === undefined) {
      throw new Error('Required parameter device_os was null or undefined when calling userLaunchInfoDeviceOsGet.');
    }

    let headers = this.defaultHeaders;

    // authentication (Bearer) required
    if (this.configuration.apiKeys['Authorization']) {
      headers = headers.set('Authorization', this.configuration.apiKeys['Authorization']);
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = [];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [];

    return this.httpClient.get<InlineResponse2009>(
      `${this.basePath}/user/launch-info/${encodeURIComponent(String(device_os))}`,
      {
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress
      }
    );
  }

  /**
   * To get the profile info
   * This API fetches the profile information of the user.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public userProfileGet(observe?: 'body', reportProgress?: boolean): Observable<InlineResponse2006>;
  public userProfileGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<InlineResponse2006>>;
  public userProfileGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<InlineResponse2006>>;
  public userProfileGet(observe: any = 'body', reportProgress: boolean = false): Observable<any> {
    let headers = this.defaultHeaders;

    // authentication (Bearer) required
    if (this.configuration.apiKeys['Authorization']) {
      headers = headers.set('Authorization', this.configuration.apiKeys['Authorization']);
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = [];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [];

    return this.httpClient.get<InlineResponse2006>(`${this.basePath}/v1/user/profile`, {
      withCredentials: this.configuration.withCredentials,
      headers: headers,
      observe: observe,
      reportProgress: reportProgress
    });
  }

  /**
   * To remove the profile picture of a user.
   * To remove the profile picture permanently from catch up.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public userProfilePicDeleteDelete(observe?: 'body', reportProgress?: boolean): Observable<InlineResponse400>;
  public userProfilePicDeleteDelete(
    observe?: 'response',
    reportProgress?: boolean
  ): Observable<HttpResponse<InlineResponse400>>;
  public userProfilePicDeleteDelete(
    observe?: 'events',
    reportProgress?: boolean
  ): Observable<HttpEvent<InlineResponse400>>;
  public userProfilePicDeleteDelete(observe: any = 'body', reportProgress: boolean = false): Observable<any> {
    let headers = this.defaultHeaders;

    // authentication (Bearer) required
    if (this.configuration.apiKeys['Authorization']) {
      headers = headers.set('Authorization', this.configuration.apiKeys['Authorization']);
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = [];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [];

    return this.httpClient.delete<InlineResponse400>(`${this.basePath}/user/profile-pic/delete`, {
      withCredentials: this.configuration.withCredentials,
      headers: headers,
      observe: observe,
      reportProgress: reportProgress
    });
  }

  /**
   * To download the profile pic of a contact number
   * This API fetches the launch information
   * @param request_contact_number The request_contact_number for which the profile pic has to be downloaded
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public userProfilePicDownloadRequestContactNumberGet(
    request_contact_number: string,
    observe?: 'body',
    reportProgress?: boolean
  ): Observable<any>;
  public userProfilePicDownloadRequestContactNumberGet(
    request_contact_number: string,
    observe?: 'response',
    reportProgress?: boolean
  ): Observable<HttpResponse<any>>;
  public userProfilePicDownloadRequestContactNumberGet(
    request_contact_number: string,
    observe?: 'events',
    reportProgress?: boolean
  ): Observable<HttpEvent<any>>;
  public userProfilePicDownloadRequestContactNumberGet(
    request_contact_number: string,
    observe: any = 'body',
    reportProgress: boolean = false
  ): Observable<any> {
    if (request_contact_number === null || request_contact_number === undefined) {
      throw new Error(
        'Required parameter request_contact_number was null or undefined when calling userProfilePicDownloadRequestContactNumberGet.'
      );
    }

    let headers = this.defaultHeaders;

    // authentication (Bearer) required
    if (this.configuration.apiKeys['Authorization']) {
      headers = headers.set('Authorization', this.configuration.apiKeys['Authorization']);
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = [];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    // if (httpHeaderAcceptSelected != undefined) {
    //     headers = headers.set('Accept', httpHeaderAcceptSelected);
    // }

    // headers = headers.set('Accept','image/png');
    headers = headers.set('Content-Type', 'image/png');

    // to determine the Content-Type header
    const consumes: string[] = [];
    return this.httpClient.get(
      `${this.basePath}/user/profile-pic-web/download/${encodeURIComponent(String(request_contact_number))}`,
      {
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
        responseType: 'arraybuffer'
      }
    );
  }

  /**
   * To upload the profile pic.
   * This API uploads the profile pic of the user in a repository and returns the file location in the response.
   * @param body image data of the profile pic that has to be uploaded.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public userProfilePicUploadPost(
    body: UploadProfilePic,
    observe?: 'body',
    reportProgress?: boolean
  ): Observable<InlineResponse400>;
  public userProfilePicUploadPost(
    body: UploadProfilePic,
    observe?: 'response',
    reportProgress?: boolean
  ): Observable<HttpResponse<InlineResponse400>>;
  public userProfilePicUploadPost(
    body: UploadProfilePic,
    observe?: 'events',
    reportProgress?: boolean
  ): Observable<HttpEvent<InlineResponse400>>;
  public userProfilePicUploadPost(
    body: UploadProfilePic,
    observe: any = 'body',
    reportProgress: boolean = false
  ): Observable<any> {
    if (body === null || body === undefined) {
      throw new Error('Required parameter body was null or undefined when calling userProfilePicUploadPost.');
    }

    let headers = this.defaultHeaders;

    // authentication (Bearer) required
    if (this.configuration.apiKeys['Authorization']) {
      headers = headers.set('Authorization', this.configuration.apiKeys['Authorization']);
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = [];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected != undefined) {
      headers = headers.set('Content-Type', httpContentTypeSelected);
    }

    return this.httpClient.post<InlineResponse400>(`${this.basePath}/user/profile-pic/upload`, body, {
      withCredentials: this.configuration.withCredentials,
      headers: headers,
      observe: observe,
      reportProgress: reportProgress
    });
  }

  /**
   * To update users profile
   * This API updates the user profile with the passed user object
   * @param body profile information of the visitor that should be stored
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public userProfilePost(body: Profile, observe?: 'body', reportProgress?: boolean): Observable<InlineResponse400>;
  public userProfilePost(
    body: Profile,
    observe?: 'response',
    reportProgress?: boolean
  ): Observable<HttpResponse<InlineResponse400>>;
  public userProfilePost(
    body: Profile,
    observe?: 'events',
    reportProgress?: boolean
  ): Observable<HttpEvent<InlineResponse400>>;
  public userProfilePost(body: Profile, observe: any = 'body', reportProgress: boolean = false): Observable<any> {
    if (body === null || body === undefined) {
      throw new Error('Required parameter body was null or undefined when calling userProfilePost.');
    }

    let headers = this.defaultHeaders;

    // authentication (Bearer) required
    if (this.configuration.apiKeys['Authorization']) {
      headers = headers.set('Authorization', this.configuration.apiKeys['Authorization']);
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = [];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected != undefined) {
      headers = headers.set('Content-Type', httpContentTypeSelected);
    }

    return this.httpClient.post<InlineResponse400>(`${this.basePath}/user/profile`, body, {
      withCredentials: this.configuration.withCredentials,
      headers: headers,
      observe: observe,
      reportProgress: reportProgress
    });
  }

  /**
   * Sets the login details
   * This API sets the login method and registers the user
   * @param body login details that are to be registered
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public userSetLoginPost(body: SetLogin, observe?: 'body', reportProgress?: boolean): Observable<InlineResponse2003>;
  public userSetLoginPost(
    body: SetLogin,
    observe?: 'response',
    reportProgress?: boolean
  ): Observable<HttpResponse<InlineResponse2003>>;
  public userSetLoginPost(
    body: SetLogin,
    observe?: 'events',
    reportProgress?: boolean
  ): Observable<HttpEvent<InlineResponse2003>>;
  public userSetLoginPost(body: SetLogin, observe: any = 'body', reportProgress: boolean = false): Observable<any> {
    if (body === null || body === undefined) {
      throw new Error('Required parameter body was null or undefined when calling userSetLoginPost.');
    }

    let headers = this.defaultHeaders;

    // authentication (basicAuth) required
    if (this.configuration.username || this.configuration.password) {
      headers = headers.set(
        'Authorization',
        'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password)
      );
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = [];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected != undefined) {
      headers = headers.set('Content-Type', httpContentTypeSelected);
    }

    return this.httpClient.post<InlineResponse2003>(`${this.basePath}/user/set-login`, body, {
      withCredentials: this.configuration.withCredentials,
      headers: headers,
      observe: observe,
      reportProgress: reportProgress
    });
  }

  /**
   * To update the login details of the user
   * This API updates the login details of the user
   * @param body login details of the user
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public userUpdateLoginPost(
    body: UpdateLogin,
    observe?: 'body',
    reportProgress?: boolean
  ): Observable<InlineResponse2005>;
  public userUpdateLoginPost(
    body: UpdateLogin,
    observe?: 'response',
    reportProgress?: boolean
  ): Observable<HttpResponse<InlineResponse2005>>;
  public userUpdateLoginPost(
    body: UpdateLogin,
    observe?: 'events',
    reportProgress?: boolean
  ): Observable<HttpEvent<InlineResponse2005>>;
  public userUpdateLoginPost(
    body: UpdateLogin,
    observe: any = 'body',
    reportProgress: boolean = false
  ): Observable<any> {
    if (body === null || body === undefined) {
      throw new Error('Required parameter body was null or undefined when calling userUpdateLoginPost.');
    }

    let headers = this.defaultHeaders;

    // authentication (Bearer) required
    if (this.configuration.apiKeys['Authorization']) {
      headers = headers.set('Authorization', this.configuration.apiKeys['Authorization']);
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = [];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected != undefined) {
      headers = headers.set('Content-Type', httpContentTypeSelected);
    }

    return this.httpClient.post<InlineResponse2005>(`${this.basePath}/user/update-login`, body, {
      withCredentials: this.configuration.withCredentials,
      headers: headers,
      observe: observe,
      reportProgress: reportProgress
    });
  }

  /**
   * To update the phone number of the user
   * This API updates the phone number of the user based on his user_id. It will cancel all the events with user_id belongs to the new phone number and country code and then updates the phone_number for the current user_id.
   * @param body phone number information that has to be updated.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public userUpdatePhoneNumberPost(
    body: UpdatePhoneNumber,
    observe?: 'body',
    reportProgress?: boolean
  ): Observable<InlineResponse400>;
  public userUpdatePhoneNumberPost(
    body: UpdatePhoneNumber,
    observe?: 'response',
    reportProgress?: boolean
  ): Observable<HttpResponse<InlineResponse400>>;
  public userUpdatePhoneNumberPost(
    body: UpdatePhoneNumber,
    observe?: 'events',
    reportProgress?: boolean
  ): Observable<HttpEvent<InlineResponse400>>;
  public userUpdatePhoneNumberPost(
    body: UpdatePhoneNumber,
    observe: any = 'body',
    reportProgress: boolean = false
  ): Observable<any> {
    if (body === null || body === undefined) {
      throw new Error('Required parameter body was null or undefined when calling userUpdatePhoneNumberPost.');
    }

    let headers = this.defaultHeaders;

    // authentication (Bearer) required
    if (this.configuration.apiKeys['Authorization']) {
      headers = headers.set('Authorization', this.configuration.apiKeys['Authorization']);
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = [];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected != undefined) {
      headers = headers.set('Content-Type', httpContentTypeSelected);
    }

    return this.httpClient.post<InlineResponse400>(`${this.basePath}/user/update-phone-number`, body, {
      withCredentials: this.configuration.withCredentials,
      headers: headers,
      observe: observe,
      reportProgress: reportProgress
    });
  }

  /**
   * Verifies the login method and registers the user
   * This API verifies the login method and registers the user
   * @param body verification data that has to be registered
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public userVerifyLoginRegisterPost(
    body: VerifyLoginRegister,
    observe?: 'body',
    reportProgress?: boolean
  ): Observable<InlineResponse2002>;
  public userVerifyLoginRegisterPost(
    body: VerifyLoginRegister,
    observe?: 'response',
    reportProgress?: boolean
  ): Observable<HttpResponse<InlineResponse2002>>;
  public userVerifyLoginRegisterPost(
    body: VerifyLoginRegister,
    observe?: 'events',
    reportProgress?: boolean
  ): Observable<HttpEvent<InlineResponse2002>>;
  public userVerifyLoginRegisterPost(
    body: VerifyLoginRegister,
    observe: any = 'body',
    reportProgress: boolean = false
  ): Observable<any> {
    if (body === null || body === undefined) {
      throw new Error('Required parameter body was null or undefined when calling userVerifyLoginRegisterPost.');
    }

    let headers = this.defaultHeaders;

    // authentication (basicAuth) required
    if (this.configuration.username || this.configuration.password) {
      headers = headers.set(
        'Authorization',
        'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password)
      );
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = [];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected != undefined) {
      headers = headers.set('Content-Type', httpContentTypeSelected);
    }

    return this.httpClient.post<InlineResponse2002>(`${this.basePath}/user/verify-login-register`, body, {
      withCredentials: this.configuration.withCredentials,
      headers: headers,
      observe: observe,
      reportProgress: reportProgress
    });
  }

  /**
   * To verify pin and confirm
   * This API verifies the pin
   * @param body Pin information that has to be verified
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public userVerifyPinPost(body: VerifyPin, observe?: 'body', reportProgress?: boolean): Observable<InlineResponse400>;
  public userVerifyPinPost(
    body: VerifyPin,
    observe?: 'response',
    reportProgress?: boolean
  ): Observable<HttpResponse<InlineResponse400>>;
  public userVerifyPinPost(
    body: VerifyPin,
    observe?: 'events',
    reportProgress?: boolean
  ): Observable<HttpEvent<InlineResponse400>>;
  public userVerifyPinPost(body: VerifyPin, observe: any = 'body', reportProgress: boolean = false): Observable<any> {
    if (body === null || body === undefined) {
      throw new Error('Required parameter body was null or undefined when calling userVerifyPinPost.');
    }

    let headers = this.defaultHeaders;

    // authentication (Bearer) required
    if (this.configuration.apiKeys['Authorization']) {
      headers = headers.set('Authorization', this.configuration.apiKeys['Authorization']);
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = [];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected != undefined) {
      headers = headers.set('Content-Type', httpContentTypeSelected);
    }

    return this.httpClient.post<InlineResponse400>(`${this.basePath}/user/verify-pin`, body, {
      withCredentials: this.configuration.withCredentials,
      headers: headers,
      observe: observe,
      reportProgress: reportProgress
    });
  }

  /**
   * Verifies the pin method and registers the user
   * This API verifies the pin and registers the user
   * @param body verification data that has to be registered
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public userVerifyPinRegisterPost(
    body: VerifyPinRegister,
    observe?: 'body',
    reportProgress?: boolean
  ): Observable<InlineResponse2004>;
  public userVerifyPinRegisterPost(
    body: VerifyPinRegister,
    observe?: 'response',
    reportProgress?: boolean
  ): Observable<HttpResponse<InlineResponse2004>>;
  public userVerifyPinRegisterPost(
    body: VerifyPinRegister,
    observe?: 'events',
    reportProgress?: boolean
  ): Observable<HttpEvent<InlineResponse2004>>;
  public userVerifyPinRegisterPost(
    body: VerifyPinRegister,
    observe: any = 'body',
    reportProgress: boolean = false
  ): Observable<any> {
    if (body === null || body === undefined) {
      throw new Error('Required parameter body was null or undefined when calling userVerifyPinRegisterPost.');
    }

    let headers = this.defaultHeaders;

    // authentication (basicAuth) required
    if (this.configuration.username || this.configuration.password) {
      headers = headers.set(
        'Authorization',
        'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password)
      );
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = [];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected != undefined) {
      headers = headers.set('Content-Type', httpContentTypeSelected);
    }

    return this.httpClient.post<InlineResponse2004>(`${this.basePath}/user/verify-pin-register`, body, {
      withCredentials: this.configuration.withCredentials,
      headers: headers,
      observe: observe,
      reportProgress: reportProgress
    });
  }
}
